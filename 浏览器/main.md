## V8垃圾回收

> [v8 垃圾回收 知乎](https://zhuanlan.zhihu.com/p/146749402)  
>
> ### 可访问性算法
>目前 V8 采用 可访问性(reachablility)算法来判断堆中的对象是否为活动对象。这个算法其实就将一些 GC Root 作为初始存活对象的集合，从 GC Root 对象触发，遍历 GC Root 中的所有对象。
>1. 能够通过 GC Root 遍历到的对象被认为是可访问的，标记为活动对象，必须保留
>2. 如果一个对象无法被 GC Root 遍历到，那么就认为这个对象不可访问，可能需要回收，标记为非活动对象
>
> 在浏览器中 GC Root 通常包括但不限于：
> - 全局 window 对象(位于每个iframe中)
> - 文档 DOM 树，由所有可访问的原生 DOM 组成
> - 存放在栈上的变量

### 调用栈中的垃圾回收
有一个记录当前执行状态的指针(称为 ESP)指向调用栈中的函数执行上下文。当函数执行完成之后，就需要销毁函数的执行上下文了，这时候，ESP 就帮上忙了，JavaScript 会将 ESP 下移到后面的函数执行上下文，这个下移的过程就是销毁当前函数执行上下文的过程。
### 堆中的垃圾回收
一般分为以下几个步骤：
1. 通过 GC Root 标记空间中的活动对象和非活动对象
2. 回收非活动对象内存
3. 内存整理。频繁回收后会产生不连贯的内存空间，即内存碎片

### 新生代与老生代
在垃圾回收领域有一个 **代际假说**，他将内存根据存活时间分为两类：
- 会持续很久的存在，如 window、DOM、Web API等
- 大部分的对象，他们在内存中存在的时间很短，如函数内部的变量，块级作用与中的变量，当函数或这块级代码执行结束时，作用域内部的变量也会被销毁

垃圾回收也就顺势把堆分为了新生代和老生代两块区域(副垃圾回收器、主垃圾回收器)，存活时间短的放在新生代，时间长放在老生代，因为新生代中的变量存活时间短，所以分配的内存空间也小（1～8M）

### 新生代算法(副垃圾回收器)
变量一般存活时间短，使用 Scavenge GC 算法  
将新生代空间对半分位对象区域和空闲区域，新加入的会放到对象区域，当对象区域快要被写满的时候就会执行一次垃圾倾倒操作  
在垃圾回收的过程中，首先会标记对象区域中的活动对象，随后会将活动对象复制到空闲区域中，同时会把这些对象有序的排列起来，此时空闲区域的对象都是被整理过的(解决内存碎片)，完成活动对象的复制后，清空此时的对象区域，再将两个区域的角色互换，就完成了非活动对象的清理以及内存空间的整理  
但分配给副垃圾收集器的空间是很小的，很快就会被填满，怎么解决呢？ **对象晋升策略**，简单来说，就是经过两次垃圾回收仍然存活的对象会被移动到老生代区

### 老生代算法
老生代中的变量一般存活时间较长且数量多，采用 **标记清除算法、标记整理算法**
标记-整理 与 标记-清除 算法中，标记的步骤是一样的，只是后续不是直接对垃圾数据清理，而是先将所有存活的对象向一端移动，然后直接清理掉这一端以外的内存

### 优化垃圾回收的执行效率
JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕之后再恢复脚本执行，我们把这个行为称之为 **全停顿(Stop-The-World)**

为了解决全停顿带来的用户体验的问题，V8 团队进行多年的努力，向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术，这些技术主要是从两个方面解决垃圾回收效率的问题：

1. 既然一个大任务执行需要花费很长时间，那么就把它拆分成多个小任务去执行。
2. 将标记、移动对象等任务转移到后台线程进行。这样大大减少主线程暂停的时间，改善页面卡顿的问题。

#### 并行回收
开辅助线程，副垃圾回收器就是采用这种策略
#### 增量回收
老生代中存放的比较大的对象，即使并行回收，也需要很长时间（标记时间长），因此产生了增量垃圾回收
将垃圾回收拆分为标记、清理、整理，同时标记可以做增量的更新，这些任务就可以穿插到主线程中去执行
#### 并发回收
...

### 为什么新一代浏览器没有使用引用计数来做垃圾回收策略
循环引用！致命的问题  
优点：
- 最大暂停时间小
- 垃圾可以被立即回收
- 不需要沿指针查找


## 浏览器渲染流程
> [chrome浏览器渲染原理](https://segmentfault.com/a/1190000038468748?utm_source=sf-similar-article)  
> [页面生命周期](https://zh.javascript.info/onload-ondomcontentloaded)
### TL;DR
- HTML解析过程
  1. DOM Tree, CSSOM Tree 解析
  3. DOM Tree, CSSOM Tree 组合成 Render Tree（一些列矩形，具有字体、颜色、尺寸等视觉元素）
  4. layout (重排 Reflow) 将render tree 的节点布局在屏幕上的正确位置
  5. painting (重绘 Repaint)
- 解析HTML时，碰到js会立即停止HTML,CSS解析（CSS不会使HTML停止）执行js再返回控制权，整个解析进程都会等待js执行完之后才能够继续
- 外部css文件和图片的获取是异步的，不会影响HTML的加载

### CSS加载与解析
- css加载不会阻塞DOM树的**解析**
- css加载会阻塞DOM树的**渲染**
- *css加载会阻塞后面js语句的执行 (由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。)*

### DOMContentLoaded，onLoad
- DOMContentLoaded 在DOM树解析完后就触发，不需要等待**样式**  
- onLoad 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：**图片，样式**等。
- beforeunload/unload —— 当用户正在离开页面时